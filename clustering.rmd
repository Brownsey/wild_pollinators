---
title: "clustering"
author: "Stephen Brownsey"
date: "25/12/2019"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### 2 step markov chain I guess
This section is going cover two step clustering based on various clustering methods for comparison.
Visit data will be combined into one bee result for each orchard, note in principle this is fundementally flawed as the data does depend on previous years and the assumption that independent of the past is false as pesticide last year affects bee population this year as would be expected. In these scenarios each implementation will have a maximum of 8 clusters. Two after pre-bloom, 4 after and 8 after post bloom.
```{r}
load("data")
markov_data <- data_2012 %>%
  select(ends_with(".pre"), ends_with(".blm"), ends_with(".pos"), orchard) %>%
  unique()

#function to generate the agglomaerative clustering
aggl <- function(data){
  agnes(dist(data, method = "euclidian"), 
                   diss=TRUE, method = "ward")
}

#function to reduce copy pasting for each node
aggl_c <- function(data, ends, c_num){
  #define temp dataset of this stage by cluster
    temp <- data %>%
    filter(cluster == c_num) %>%
    select(ends_with(ends))
    
#If statement as if 1 element in dataset it'll error    
if(nrow(temp) > 1){
  temp$cluster <- cutree(aggl(temp) , k = 2)
  
   output <- data %>% 
    filter(cluster == c_num) %>%
    select(-cluster) %>%
    mutate(cluster = temp$cluster)
   #Else statement for if 1 element in dataset
  }else{
    output <- temp %>%
      mutate(cluster == 1)
  }
  output
}

aggl_c(aggl_node1, ".blm", 1)

####Agglomerative heirachicale clustering
#pre-bloom step
temp <- markov_data %>%
  select(ends_with(".pre"))
  
temp$cluster <- cutree(aggl(temp) , k = 2)

aggl_node1 <- markov_data %>% 
  mutate(cluster = temp$cluster)

#during bloom step 1
aggl_node2 <- aggl_c(aggl_node1, ".blm", 1)
  
#during bloom step 2
aggl_node3 <- aggl_c(aggl_node1, ".blm", 2)


#post bloom step 1
aggl_node4 <- aggl_c(aggl_node2, ".pos", 1)
  
#post bloom step 2
aggl_node5 <- aggl_c(aggl_node2, ".pos", 2)

#post bloom step 3
aggl_node6 <- aggl_c(aggl_node3, ".pos", 1)
  
#post bloom step 4
#Need to add error catch if n < 2 as this cant be passed in to a k with 2
aggl_node7 <- aggl_c(aggl_node3, ".pos", 2)
```

kmeans approach:

```{r}
#function to generate the kmeans clustering
k_clustering <- function(data, n = 1001){
#creating the dataset to then calculate the optimal cluster from  
  for(i in 1:n){
  if(i == 1){
     k_list <- tibble(kmeans(data, 2)$cluster)
  }else{
     k_list <- bind_cols(k_list, tibble(kmeans(data, 2)$cluster))
  }
  
  }
  apply(k_list[ ,1:length(k_list)], 1, mfv1) %>% 
    enframe(value = "cluster") %>%
    select(cluster)
}
#pre-bloom step



#Getting the most common clustering 
a <- k_clustering(markov_data %>% select(-orchard))


kmeans_c <- function(data, ends, c_num){
  
  data <- data %>%
    filter(cluster == c_num) %>%
    select(-cluster)
  
  if(nrow(data) > 2){
    temp <- data  %>%
    select(ends_with(ends))
  
  cluster <- k_clustering(temp, 2)
 output <- bind_cols(data, cluster)
  }else{
    #Not more than 2 rows and get the error message as:
    #number of cluster centres must lie between 1 and nrow(x)
    output <- data %>%
      mutate(cluster = 1)
  }

 output
}


temp <- k_clustering(markov_data %>% select(-orchard))

kmeans_node1 <- markov_data %>% 
  bind_cols(temp)


#during bloom step 1
kmeans_node2 <- kmeans_c(kmeans_node1, ".blm", 1)
  
#during bloom step 2
kmeans_node3 <- kmeans_c(kmeans_node1, ".blm", 2)


#post bloom step 1
kmeans_node4 <- kmeans_c(kmeans_node2, ".pos", 1)
  
#post bloom step 2
kmeans_node5 <- kmeans_c(kmeans_node2, ".pos", 2)

#post bloom step 3
kmeans_node6 <- kmeans_c(kmeans_node3, ".pos", 1)
  
#post bloom step 4
#Need to add error catch if n < 2 as this cant be passed in to a k with 2
kmeans_node7 <- kmeans_c(kmeans_node3, ".pos", 2)
```

## Clustering Summarising

```{r}
get_name <- function(x) {
  deparse(substitute(x))
}



bee_values <- data_2012 %>%
  group_by(orchard) %>%
  summarise(mean_honey_ab = mean(apisAb),
            mean_wild_ab = mean(wildAbF),
            mean_wild_rich = mean(wildRichF)
            )



clusterise <- function(cluster_data, v_name = deparse(substitute(cluster_data))){
  inner_join(bee_values, cluster_data) %>%
    summarise(mean_honey_ab = mean(mean_honey_ab),
              mean_wild_ab = mean(mean_wild_ab),
              mean_wild_rich = mean(mean_wild_rich)) %>%
    mutate(cluster = v_name)
}

agglom_bees <- clusterise(aggl_node1) %>%
  bind_rows(clusterise(aggl_node2)) %>%
  bind_rows(clusterise(aggl_node3)) %>%
  bind_rows(clusterise(aggl_node4)) %>%
  bind_rows(clusterise(aggl_node5)) %>%
  bind_rows(clusterise(aggl_node6)) %>%
  bind_rows(clusterise(aggl_node7)) %>%
  bind_rows(clusterise(aggl_node2)) %>%


```